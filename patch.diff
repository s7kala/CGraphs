diff --git a/source/graphimpl.cc b/source/graphimpl.cc
index d7c49f5..e6188af 100644
--- a/source/graphimpl.cc
+++ b/source/graphimpl.cc
@@ -246,18 +246,20 @@ void GraphImpl::set_connected() {
 // TO-DO
 // if graph is bipartite, set bipartite to 1, else to 0
 // assume G is non-empty
-bool color_bipartite(Vertex& parent, std::vector<Vertex>& visited, GraphImpl& gp) {
+bool color_bipartite(Vertex& parent, std::vector<Vertex>& visited, std::map<std::string, int>& color, GraphImpl& gp) {
     int index = get_location(parent, gp);
     // go through neigbhours of parent
     for (auto &it : gp.G.at(index).second){
         // if neigbhours haven't been visited
         if(!exists_in(visited, it)){
             visited.emplace_back(it);
-            gp.G.at(get_location(it, gp)).first.color = !gp.G.at(get_location(parent, gp)).first.color;
-            if(!color_bipartite(it, visited, gp)) return false;
+            //gp.G.at(get_location(it, gp)).first.color = !gp.G.at(get_location(parent, gp)).first.color;
+            color[it.name] = !color[parent.name];
+            if(!color_bipartite(it, visited, color, gp)) return false;
         }
-        else if(gp.G.at(get_location(parent, gp)).first.color == gp.G.at(get_location(it, gp)).first.color){
-            std::cerr << "The vertices " << it << " and " << parent << " are of the same color" << std::endl;
+        //else if(gp.G.at(get_location(parent, gp)).first.color == gp.G.at(get_location(it, gp)).first.color){
+        else if(color[it.name] == color[parent.name]) {
+            std::cerr << "The vertices " << it.name << " and " << parent.name << " are of the same color" << std::endl;
             return false;
         }
     }
@@ -269,15 +271,20 @@ void GraphImpl::set_bipartite() {
     if(G.size() == 0) bipartite = 1;
     else {
         std::vector<Vertex> visited;
-        G.at(0).first.color = 0;
+        std::map<std::string, int> color;
+        //G.at(0).first.color = 0;
+        color[G.at(0).first.name] = 0;
         visited.emplace_back(G.at(0).first);
-        if(color_bipartite(G.at(0).first, visited, *this)) bipartite = 1;
+        if(color_bipartite(G.at(0).first, visited, color, *this)) bipartite = 1;
         else bipartite = 0;
         // cleanup
-        for(auto &it : G) {
-            std::cout << it.first << ": " << it.first.color << '\n';
-            it.first.color = -1;
+        for (auto &it : color){
+            std::cout << it.first << ": " << it.second << "\n";
         }
+        /*for(auto &it : G) {
+            std::cout << it.first << ": " << it.first.color << '\n';
+            it.first.color = -1; 
+        } */
     }
 }
 
diff --git a/source/graphimpl.h b/source/graphimpl.h
index 6d94323..cc6ebec 100644
--- a/source/graphimpl.h
+++ b/source/graphimpl.h
@@ -10,7 +10,8 @@
 
 struct Vertex {
     std::string name;
-    int degree, color = -1;
+    int degree; 
+    //int color = -1;
     // add neighbours list?
     Vertex(std::string n = "", int deg = 0): name{n}, degree{deg} {}
     bool operator==(const Vertex& v) { return (name == v.name); }
